# /lib/delayed_duplicate_prevention_plugin.rb
require 'delayed_job'
class DelayedDuplicatePreventionPlugin < Delayed::Plugin
 
  module SignatureConcern
    extend ActiveSupport::Concern

    included do
      before_validation :add_signature
      before_validation :delete_previous_duplicate
      validate :prevent_duplicate
    end

    attr_writer :strategy

    private
    def add_signature
      self.signature = generate_signature
      self.args = self.payload_object.args.to_yaml
    end

    def generate_signature
      pobj = payload_object
      if pobj.object.respond_to?(:id) and pobj.object.id.present?
        sig = "#{pobj.object.class}"
        sig += ":#{pobj.object.id}" 
      else
        sig = "#{pobj.object}"
      end
      
      sig += "##{pobj.method_name}"
      return sig
    end    
    
    def delete_previous_duplicate
      if @strategy == :delete_previous
        dup_check = DuplicateChecker.new(self)
        delete_job(dup_check.duplicates) if dup_check.duplicate?
        logger.debug "__________: #{self.class} #{__method__} DELETED #{dup_check.duplicates.count} dupes"
      end
    end
    
    def delete_job(jobs)
      jobs.each do |id|
        Delayed::Job.destroy(id)
      end
    end

    def prevent_duplicate
      #logger.debug "__________: #{self.class} #{__method__} done"
      if DuplicateChecker.duplicate?(self)
        Rails.logger.warn "Found duplicate job(#{self.signature}), ignoring..."
        errors.add(:base, "This is a duplicate") 
      end
    end
  end

#TODO duplicitní DelayedJob: když se změní jakýkoli atribut argumentu (@user - např. gifts_count, apod.) tak se job nevyhodnotí jako duplicitní
  class DuplicateChecker
    attr_reader :job, :duplicates
    attr_writer 

    def self.duplicate?(job)
      new(job).duplicate?
    end

    def initialize(job)
      @job = job
    end
    
    def duplicate?
      possible_dupes = Delayed::Job.where(signature: job.signature)
      possible_dupes = possible_dupes.where.not(id: job.id) if job.id.present?
      dupes = []
      result = possible_dupes.any? do |possible_dupe| 
        dupes << possible_dupe if args_match?(possible_dupe, job)
      end
      self.duplicates = dupes
      result
    end

    private

    def duplicates=(dupes)
      @duplicates = dupes
    end

    def args_match?(job1, job2)
      # TODO: make this logic robust
      normalize_args(job1.args) == normalize_args(job2.args)
    end

    def normalize_args(args)
      args.kind_of?(String) ? YAML.load(args) : args
    end
  end
end